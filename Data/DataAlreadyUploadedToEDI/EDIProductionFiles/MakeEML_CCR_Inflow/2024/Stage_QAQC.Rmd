---
title: "Stage_QAQC"
author: "AEB and DWH"
date: "2026-01-22"
output: html_document
---
Edits: ABP - changed the barometric pressure to average to get 10 more observations. Calculated depth using the relationship between hydro static pressure and height of the water column. Changed flags - added 2 for missing data, 3 for negative water level and changed to 0, 5 for negative pressure but not changed. Put the code in to run through the maintenance column. For comparing the water level to manual measurements used the closest observation as opposed to the average. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

pacman::p_load(dplyr, tidyverse, httr2, jsonlite, plotly, googlesheets4, ggpmisc, rLakeAnalyzer, zoo, dataRetrieval)

```

## Import all PT data

Pull all .csv files of direct data downloads from PT

```{r load data, echo = TRUE}

#Identify which GitHub Folder to pull folder names from
url <- "https://api.github.com/repos/CareyLabVT/ManualDownloadsSCCData/contents/CCR_manual_downloads/CCR_Hobos/HPB_waterlevel"

#create list of file names
resp <- request(url) |>
  req_headers(Accept = "application/vnd.github+json") |>
  req_perform()

dat <- resp_body_json(resp, simplifyVector = TRUE)

file_names <- dat$name

#only select .csv files
file_names <- file_names[grepl("\\.csv$", file_names)]

#add to link 
git_link <- "https://raw.githubusercontent.com/CareyLabVT/ManualDownloadsSCCData/master/CCR_manual_downloads/CCR_Hobos/HPB_waterlevel/"

file_names <- paste0(git_link, file_names)

#import .csv files
hobo_raw <- bind_rows(
  lapply(file_names, function(f) {

    df <- read_csv(
      f,
      skip = 1,
      locale = locale(encoding = "UTF-8"),
      show_col_types = FALSE
    )

    df |>
      select(
        DateTime_EDT = contains("Date Time"),
        HOBO_Abs_Pres_kPa = contains("Abs Pres"),
        Temp_C = contains("Temp")
      ) |>
      mutate(
        DateTime_EDT = parse_datetime(DateTime_EDT, format = "%m/%d/%y %I:%M:%S %p"),
        HOBO_Abs_Pres_kPa = as.numeric(HOBO_Abs_Pres_kPa),
        Temp_C = as.numeric(Temp_C),
        )
  })
)

```
## Manage Data

Set Timezone, Column names, data types

```{r Data wrangling, echo = TRUE}
#Set tz to EST for PT data
#force timezone to be UTC-4 since that's what the sensor was set at. 

# #now put into GMT-5 from GMT-4
    hobo_raw$DateTime_EDT <- force_tz(as.POSIXct(hobo_raw$DateTime_EDT), tz = "Etc/GMT+5") #get dates aligned

# pre time change data gets assigned proper timezone then corrected to GMT -5 to match the rest of the data set
    hobo_raw$DateTime <- with_tz(force_tz(hobo_raw$DateTime_EDT,"Etc/GMT+4"), "EST") 

#select useful columns  
hobo_raw <- hobo_raw |>
  select(DateTime,HOBO_Abs_Pres_kPa,Temp_C)|>
  arrange(DateTime)|> # put the date time in order
  drop_na() |> # drop any NAs from the data set
  dplyr::distinct(DateTime, .keep_all = TRUE) # take out dups from overlapping data in uploads

```

## Look at data before correcting for barometric pressure/maintenence log
This is just a check to make sure all raw data came in and looks like it should

```{r Raw data plot, echo = TRUE}
ggplot(data = hobo_raw, aes(x = DateTime)) +
  geom_line(aes(y = HOBO_Abs_Pres_kPa)) +
  scale_x_datetime()
  
ggplot(data = hobo_raw, aes(x = DateTime)) +
  geom_line(aes(y = Temp_C)) +
  scale_x_datetime()

```
## Correct pressure data with Barometric Pressure from met station on dam
The HOBO PTs are not vented. This corrects to local air pressure fluctuations.

```{r Correct for barometric pressure, echo = TRUE}
ccr_met_edi <- read_csv("https://pasta.lternet.edu/package/data/eml/edi/1105/4/8ebf27393ccafe518328468a260d2e18")
 ccr_met_git <- read_csv("https://raw.githubusercontent.com/FLARE-forecast/CCRE-data/refs/heads/ccre-dam-data-qaqc/ccre_met_L1.csv")

ccr_met1 <- ccr_met_edi |>
  select(-starts_with("Note")) |> #remove note columns to bind
  rbind(ccr_met_git)

ccr_met <- ccr_met1 |> 
  select(DateTime, BP_Average_kPa, Flag_BP_Average_kPa, Rain_Total_mm) |> #check BP flag
  mutate(Date = as.Date(DateTime),
         Hour = hour(DateTime),
         Min = minute(DateTime))|>
  # filter(Min %in% c(0,10,20,30,40,50)) |>  #get just minutes to line up w/ HOBO
  # let's average the BP over the 10 minutes
  mutate(DateTime = round_date(DateTime,"10 minutes"))|>
  dplyr::group_by(DateTime)|>
  dplyr::summarise(BP_Average_kPa = mean(BP_Average_kPa, na.rm = T))|>
  select(DateTime, BP_Average_kPa)

#force into correct time zone (EST)
ccr_met$DateTime <- force_tz(as.POSIXct(ccr_met$DateTime), tzone = "EST")

#check that it worked
attr(ccr_met$DateTime, "tzone")

#correct to water level data
hobo <- left_join(hobo_raw, ccr_met, by = "DateTime") |> 
  mutate(corrected_Pres_kPa = HOBO_Abs_Pres_kPa - BP_Average_kPa) |>
  select(DateTime, HOBO_Abs_Pres_kPa, BP_Average_kPa, corrected_Pres_kPa, Temp_C) 


# Viz the corrected pressure

pres <- hobo|>
  ggplot(aes(x = DateTime, y = corrected_Pres_kPa))+
  geom_point()+
  theme_bw()

pres

#ggplotly(pres)

```



## Assign flags
Flags for dataset are:
0: good data
1: Sensor was out of water (maintenance, low water level, below freezing), value set to NA
2: missing data 
#3: negative waterlevel set to 0 
4: Correction applied
5: negtaive PT or Temp


```{r maintenance log, echo = TRUE}
#Load maintenance log
#maint_log <- read_csv("https://raw.githubusercontent.com/CareyLabVT/Reservoirs/master/Data/DataAlreadyUploadedToEDI/EDIProductionFiles/MakeEML_CC#R_Inflow/2024/hpb_maintenancelog_2024.csv")

# for loop to create flag columns
  for(j in colnames(hobo |> select(HOBO_Abs_Pres_kPa:Temp_C))) { 
    #for loop to create new columns in data frame
    hobo[,paste0("Flag_",colnames(hobo[j]))] <- 0 #creates flag column + name of variable
    hobo[c(which(is.na(hobo[,j]))),paste0("Flag_",j)] <-2 #puts in flag 2 if value not collected
  }

#Local one for now
log <- read_csv2("./hpb_maintenancelog_2024_2025.csv")

#force Maintenance Log into EST tz
log$TIMESTAMP_start <- force_tz(as.POSIXct(log$TIMESTAMP_start, format = "%m/%d/%Y %H:%M"), tzone = "EST")
log$TIMESTAMP_end <- force_tz(as.POSIXct(log$TIMESTAMP_end, format = "%m/%d/%Y %H:%M"), tzone = "EST")


# Use the code to run through the maintenance log and flag based on what is in the maintenance log

 if(nrow(log)==0){
    print('No Maintenance Events Found...')
    
  } else {
    
    for(i in 1:nrow(log))
    {
      ### get start and end time of one maintenance event
      start <- log$TIMESTAMP_start[i]
      end <- log$TIMESTAMP_end[i]
      
      
      ### Get the Reservoir
      
      Reservoir <- log$Reservoir[i]
      
      ### Get the Site
      
      Site <- log$Site[i]
      
      ### Get the Maintenance Flag 
      
      flag <- log$flag[i]
      
      ### Get the Value or text that will be replaced
      
      update_value <- as.numeric(log$update_value[i])
      
      ### Get the code for fixing values. If it is not an NA
      
        # These adjustment_code are expressions so they should not be set to numeric
        adjustment_code <- log$adjustment_code[i]
        
      
      ### Get the names of the columns affected by maintenance
      
      colname_start <- log$start_parameter[i]
      colname_end <- log$end_parameter[i]
      
      ### if it is only one parameter parameter then only one column will be selected
      
      if(is.na(colname_start)){
        
        maintenance_cols <- colnames(hobo%>%select(any_of(colname_end))) 
        
      }else if(is.na(colname_end)){
        
        maintenance_cols <- colnames(hobo%>%select(any_of(colname_start)))
        
      }else{
        maintenance_cols <- colnames(hobo%>%select(c(colname_start:colname_end)))
      }
      
      
      ### Get the name of the flag column
      
      flag_cols <- paste0("Flag_", maintenance_cols)
      
      
      ### Getting the start and end time vector to fix. If the end time is NA then it will put NAs 
      # until the maintenance log is updated
      
      if(is.na(end)){
        # If there the maintenance is on going then the columns will be removed until
        # and end date is added
        Time <- hobo$DateTime >= start
        
      }else if (is.na(start)){
        # If there is only an end date change columns from beginning of data frame until end date
        Time <- hobo$DateTime <= end
        
      }else {
        
        Time <- hobo$DateTime >= start & hobo$DateTime <= end
        
      }
      
      ### This is where information in the maintenance log gets removed. Each flag has a different scenario so 
      # a flag that removes values can not also change a value. If there are different scenarios with in a data
      # flag then have a nested if statement with other identifying things such as specific columns for that situation. 
      
      # replace relevant data with NAs and set flags while maintenance was in effect
      if (flag==1){
        # The observations are changed to NA for maintenance or other issues found in the maintenance log
        hobo[Time, maintenance_cols] <- NA
        hobo[Time, flag_cols] <- flag
        
      } else if (flag==2){
        
        # The observations are changed to NA for maintenance or other issues found in the maintenance log
        hobo[Time, maintenance_cols] <- NA
        hobo[Time, flag_cols] <- flag
        
      } else if (flag==4){
        # Values are removed because they are out of range
        # put the adjusted value in a new column. The equation used to correct the value is in the maintenance log
        ##THIS needs to be able to handle interpolation of offset (ie start time has 0.5 offset and end time has 0.2 offset), not sure if it will work that way as written currently
        hobo[Time, maintenance_cols] <- eval(parse(text=adjustment_code))
        
        hobo[Time, flag_cols] <- flag
        
      }else{
        # Flag is not in Maintenance Log
        warning(paste0("Flag", flag, "used not defined in the L1 script. 
                     Talk to Austin and Adrienne if you get this message"))
      }
    } 
  }  

```




```{r}

#Plot corrected pressure 

check_pressure <- hobo|>
  #filter(DateTime > as.Date("2025-06-10") & DateTime < as.Date("2025-06-15"))|>
  # mutate(cor_pres = HOBO_Abs_Pres_kPa - BP_Average_kPa)|>
  ggplot(aes(x = DateTime))+
  geom_point(aes(y = corrected_Pres_kPa)) +
  # geom_point(aes(y = cor_pres), color = "red") +
  theme_bw()

check_pressure

```






##Correction offsets fpr second PT deployement and flag negative PT 
```{r Correct offsets flag 4, echo = TRUE}

# calculate the height of the water column from the pressure using the relationship between hydro static pressure and height

# p = ρgh

# p = pressure in liquid (N/m2, Pa, lbf/ft2, psf)

# ρ = density of liquid (kg/m3, slugs /ft3)

# g = acceleration of gravity (9.81 m/s2, 32.17405 ft/s2)

# h = height of fluid column - or depth in the fluid where pressure is measured (m, ft)

# so h = p/(ρg)

# 1) Need to convert temperature to density. 
# 2) We are assuming that salinity is 0 and that is a very fair assumption

stage_obs <- hobo|>
  mutate(density = water.density(Temp_C),
         waterlevel_cm = ((corrected_Pres_kPa*1000)/(9.81*density))*100)|>
  # remove the density column because we don't need it any more
  select(-density)|>
  # make a flag column for water level
  # Add a flag column for when water level is negative and set to 0 and flag when pressure is negative
  mutate(Flag_waterlevel_cm = 0,
         Flag_waterlevel_cm = ifelse(waterlevel_cm < 0, 3, Flag_waterlevel_cm),
         #waterlevel_cm = ifelse(waterlevel_cm < 0, 0, waterlevel_cm), ##This data actually looks good, the reference elevation of 0 is just higher than the PT
         Flag_corrected_Pres_kPa = ifelse(corrected_Pres_kPa < 0, 5, Flag_corrected_Pres_kPa),
         Flag_corrected_Pres_kPa = ifelse(Flag_HOBO_Abs_Pres_kPa == 1, 1, Flag_corrected_Pres_kPa),
         Flag_waterlevel_cm = ifelse(Flag_HOBO_Abs_Pres_kPa == 1, 1, Flag_waterlevel_cm))|>
  select(DateTime, HOBO_Abs_Pres_kPa, BP_Average_kPa, corrected_Pres_kPa, waterlevel_cm, Temp_C, everything())

# Double check that all missing data have flags

for(j in colnames(stage_obs |> select(HOBO_Abs_Pres_kPa:Temp_C))) { 
    
    stage_obs[c(which(is.na(stage_obs[,j] & is.na(stage_obs[,paste0("Flag_",j)])))),paste0("Flag_",j)] <- 2 #puts in flag 2 if value not collected
  }
  



```

## Gap fill for missing periods less than 3 hours
Should eventually add... reasonable inference esp since most deleted times of this length we are there and can note any serious waterlevel changes. Better/more continuous we can get the PT data looking, the better the discharge data will be. Should be able to build a complete timeseries df, use zoo na.approx with tsibble for multiple sites, and then remove NA rows of table for gaps longer than fill length. https://thedatahall.com/filling-gaps-in-time-series-and-panel-data-using-r/, but  

```{r Gap fill}

seq_filled <- seq(
  from = min(stage_obs$DateTime),
  to = max(stage_obs$DateTime),
  by = "10 min"
)

stage_filled <- stage_obs |>
  complete(DateTime = seq_filled)

stage_filled <- stage_filled |>
  mutate(
    waterlevel_cm_filled = na.approx(
      waterlevel_cm,
      x = DateTime,
      maxgap = 18,
      na.rm = FALSE
    ),
    Flag_waterlevel_cm = if_else(
      is.na(waterlevel_cm) & !is.na(waterlevel_cm_filled),
      as.numeric(paste0(Flag_waterlevel_cm, 7)),
      as.numeric(Flag_waterlevel_cm)
    )
  )

#adjust datum so no negatives for good looking values 
##Future this will be done in field by choosing reference point elevation well above zero. 
datum <- 20

stage_final <- stage_filled |>
  mutate(
    stage_cm = waterlevel_cm_filled + datum
  )|>
  select (DateTime, HOBO_Abs_Pres_kPa, BP_Average_kPa, corrected_Pres_kPa, stage_cm, Temp_C, Flag_HOBO_Abs_Pres_kPa, Flag_BP_Average_kPa, Flag_corrected_Pres_kPa, Flag_waterlevel_cm, Flag_Temp_C) |>
  rename(
    Flag_stage_cm = Flag_waterlevel_cm
  )


# save data file 
write.csv(stage_final, "HPB_stage_2024_2025.csv", row.names = F)

```
```{r USGS Reference Gage}
ref_site <- "USGS-02055100"

USGS_Ref <- read_waterdata_continuous(
  monitoring_location_id = ref_site,
  parameter_code = "00065",
  properties = c("time", "value", "unit_of_measure"),
  time = paste0(min(stage_final$DateTime), "/",max(stage_final$DateTime))
)

USGS_Ref <- USGS_Ref |>
  mutate(
    stage_cm = value * 30.48
  )

```



##View with manual stage measurements
```{r View manual measurements on timeseries, echo = TRUE}

#Pull manual stage measurement file
stage_checks <-  gsheet::gsheet2tbl("https://docs.google.com/spreadsheets/d/1OOh1QfOad3ez_Hk4Sl8ziPYxmWWcoSv1GNeuJkrFec8")

#format date column
stage_checks$DateTime = lubridate::parse_date_time(stage_checks$DateTime, orders = c('ymd HMS','ymd HM','ymd', 'mdy','mdy HM', 'mdy HMS', 'mdy HM'), tz = "America/New_York")

# convert to EST
stage_checks$DateTime <- with_tz(as.POSIXct(stage_checks$DateTime), tz = "EST")

# convert manual measurements to stage w offset applied above
stage_checks <- stage_checks |>
  mutate(
    manual_stage_cm = manual_depth_cm + datum
  )

# make a plot of stage water level with manual points on top
p <- ggplot() +
  geom_point(data = stage_final, aes(x = DateTime, y = stage_cm)) +
  geom_point(data = stage_checks, aes(x = DateTime, y = manual_stage_cm), color = "red") +
  ggtitle("Staged data with manual points overlaid in red") +
  theme_bw()

ggplotly(p)

pp <- ggplot() +
  geom_point(data = stage_final, aes(x = DateTime, y = stage_cm)) +
  geom_point(data = USGS_Ref, aes(x = time, y = stage_cm), color = 'blue') +
  ggtitle("Staged data USGS comparison site") +
  theme_bw()

ggplotly(pp)

 # find the closest date and then join the two data frames
# drop the NA waterlevel

wl <- stage_final|>
  select(DateTime, stage_cm)|>
  drop_na()

  by <- join_by(closest(DateTime <= DateTime))
  compare <- left_join(stage_checks, wl, by)|>
    dplyr::rename(DateTime = DateTime.x)


#Filter to pull dates from each specific PT deployment
PT1 <- compare %>%
   filter(DateTime >= as.POSIXct("2024-04-23", tz = "America/New_York"),
         DateTime <= as.POSIXct("2024-12-17", tz = "America/New_York"))

PT2 <- compare %>%
   filter(DateTime >= as.POSIXct("2025-03-01", tz = "America/New_York"),
         DateTime <= as.POSIXct("2025-12-02", tz = "America/New_York"))

#Plot comparison of PT to manual measured stage for 1st PT deployment
ggplot(data = PT1, aes(x = stage_cm, y = manual_stage_cm))+ 
  geom_point()+
  stat_poly_line(method = "lm", linewidth = 2)+
  stat_poly_eq(formula=y~x, label.x = "left", label.y="top", parse=TRUE, inherit.aes = F,
               aes(x = stage_cm, y = manual_stage_cm, label=paste(..adj.rr.label..,..p.value.label..,sep="~~~"),size=3))+
  labs(title = "PT1")

#Plot comparison of PT to manual measured stage for 2nd PT deployment
ggplot(data = PT2, aes(x = stage_cm, y = manual_stage_cm))+ 
  geom_point()+
  stat_poly_line(method = "lm", linewidth = 2)+
  stat_poly_eq(formula=y~x, label.x = "left", label.y="top", parse=TRUE, inherit.aes = F,
               aes(x = stage_cm, y = manual_stage_cm, label=paste(..adj.rr.label..,..p.value.label..,sep="~~~"),size=3))+
  labs(title = "PT2")


```

##Visualize differences between PT sensor reading and manual measurement

```{r Visualize PT v manual measurements, echo = TRUE}
selected_compare <- compare |>
  filter(!is.na(stage_cm), !is.na(manual_stage_cm))

selected_compare$difference <- selected_compare$stage_cm - selected_compare$manual_stage_cm

ggplot(data = selected_compare, aes(x = DateTime, y = difference))+
  geom_point()+
  ylab("PT - manual depth (cm)")

```

##Visualize qaqc parameters ie manual measurements, temp
Use this graph to visually qaqc PT data-- 
  1. When PT comes out of the water as seen by drastic temp change/larger diurnal swings and flat lining of PT data
  2. When site visit measurements don't line up with PT data
  3. Gaps or odd jumps in water level
  
  
```{r temp and corrected stage, echo = TRUE}

a <- ggplot(data = stage_final, aes(x = DateTime)) +
  geom_point(aes(y = stage_cm)) +
  geom_line(aes(y = Temp_C), color = "blue")
a
```


```{r Compare with precip, echo = TRUE}

rain_comp <- left_join(stage_final, ccr_met1, by = "DateTime")

ggplot(data = rain_comp, aes(x = DateTime)) +
  geom_line(aes(y = stage_cm)) +
  geom_col(aes(y = Rain_Total_mm*10), color = "blue")+ #x 10 rain for better viewing
  scale_x_datetime()
  
```

```{r Compare with manual measurements, echo = TRUE}
a <- ggplot(data = compare, aes(x = DateTime)) +
  geom_point(aes(y = stage_cm)) +
  geom_point(aes(y = manual_stage_cm), color = "red")

a
#ggplotly(a)

```

